#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')
begin
  require 'redis'
rescue LoadError
  require 'rubygems'
  require 'redis'
end
require 'soulmate'
require 'optparse'
require 'tempfile'

parser = OptionParser.new do |opts|
  opts.banner = "Usage: soulmate [options] COMMAND"

  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--redis [HOST:PORT]", "Redis connection string") do |host|
    Soulmate.redis = host
  end

  opts.on("-s", "--stop-words [FILE]", "Path to file containing a list of stop words") do |fn|
    File.open(fn) do |file|
      Soulmate.stop_words = file.readlines.map{ |l| l.strip }.reject{ |w| w.empty? }
    end
  end

  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.on("-b", "--batch-size", "Number of lines to read at a time") do |size|
    BATCH_SIZE = size
  end

  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  load   TYPE FILE  Replaces collection specified by TYPE with items read from FILE in the JSON lines format."
  opts.separator "  add    TYPE       Adds items to collection specified by TYPE read from stdin in the JSON lines format."
  opts.separator "  remove TYPE       Removes items from collection specified by TYPE read from stdin in the JSON lines format. Items only require an 'id', all other fields are ignored."
  opts.separator "  query  TYPE QUERY Queries for items from collection specified by TYPE."
end

def generate(type, file)
  include Soulmate::Helpers

  begin
    temp = Tempfile.new("soulmate")

    if File.exists?(file)
      start_time = Time.now.to_i
      base = "soulmate-index:#{type}"
      database = "soulmate-data:#{type}"
      # hset = "*4\r\n$4\r\nHSET\r\n$#{database.length}\r\n#{database}\r\n$"
      # del = "*2\r\n$3\r\nDEL\r\n$"
      begin
        f = File.open(file)
        # cleanup
        phrases = Soulmate.redis.smembers(base)
        phrases.each do |phrase|
          temp << gen_redis_proto("DEL", phrase)
          # temp << del + phrase.length.to_s + "\r\n" + phrase + "\r\n"
        end
        temp << gen_redis_proto("DEL", base)
        # temp << del + base.length.to_s + "\r\n" + base + "\r\n"
        while !f.eof?
          line = f.gets.chomp
          line =~ /"id":(\d+)/
          id = $1
          line =~ /"score":(\d+)/
          score = $1
          json = MultiJson.decode(line)
          temp << gen_redis_proto("HSET", database, id, line)
          # temp << hset + $1.length.to_s + "\r\n" + $1 + "\r\n$" + line.length.to_s + "\r\n" + line + "\r\n"
          phrase = json.key?("aliases") ? json["term"] + " " + json["aliases"] : json["term"]
          prefixes_for_phrase(phrase).each do |p|
            temp << gen_redis_proto("SADD", base, p)
            temp << gen_redis_proto("ZADD", base + ":" + p, score, id)
          end
        end
      ensure
        f.close
      end
      puts "Converted in #{Time.now.to_i - start_time} second(s)"
      puts "Importing into redis ..."
      `time redis-cli --pipe < #{temp.path}`
    else
      puts "Couldn't open file: #{file}"
    end
  ensure
    temp.close
  end
end

def load(type, file)
  if File.exists?(file)
    start_time = Time.now.to_i

    puts "Purging existing items of type #{type} ..."
    loader = Soulmate::Loader.new(type)
    loader.cleanup

    puts "Loading items of type #{type} in batches of #{BATCH_SIZE} ..."
    count = 0
    begin
      f = File.open(file)
      while !f.eof?
        lines = []
        BATCH_SIZE.times do
          break if f.eof?
          lines << MultiJson.decode(f.gets)
          count += 1
        end
        loader.load(lines)
        puts "Loaded #{count} items ..." unless f.eof?
      end
    ensure
      f.close
    end
    puts "Loaded a total of #{count} items in #{Time.now.to_i - start_time} second(s)"
  else
    puts "Couldn't open file: #{file}"
  end
end

def add(type)
  puts "Adding items of type #{type}..."
  loader = Soulmate::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.add(item)
  end
  puts "Loaded a total of #{items.size} items"
end

def remove(type)
  puts "Removing items of type #{type}..."
  loader = Soulmate::Loader.new(type)
  items = $stdin.read.split("\n").map { |l| MultiJson.decode(l) }
  items.each do |item|
    loader.remove(item)
  end
  puts "Removed a total of #{items.size} items"
end

def query(type, query)
  puts "> Querying '#{type}' for '#{query}'"
  matcher = Soulmate::Matcher.new(type)
  results = matcher.matches_for_term(query, :limit => 0)
  results.each do |item|
    puts MultiJson.encode(item)
  end
  puts "> Found #{results.size} matches"
end

def gen_redis_proto(*cmd)
  proto = "*"+cmd.length.to_s+"\r\n"
  cmd.each{|arg|
    proto << "$"+arg.bytesize.to_s+"\r\n"
    proto << arg+"\r\n"
  }
  proto
end

parser.parse!
BATCH_SIZE ||= 1000

case ARGV[0]
when 'generate'
  generate ARGV[1], ARGV[2]
when 'load'
  load ARGV[1], ARGV[2]
when 'add'
  add ARGV[1]
when 'remove'
  remove ARGV[1]
when 'query'
  query ARGV[1], ARGV[2]
else
  puts parser.help
end
